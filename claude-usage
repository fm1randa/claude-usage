#!/bin/bash
#
# claude-usage.sh - Fetch Claude Plan usage statistics
#
# Based on the CodexBar implementation by steipete
# https://github.com/steipete/CodexBar
#
# This script fetches your Claude usage via the Anthropic OAuth API.
# It uses credentials from Claude Code (the CLI tool).
#
# Prerequisites:
#   1. Install Claude Code: npm install -g @anthropic-ai/claude-code
#   2. Login: claude login
#   3. Run this script
#
# Usage: ./claude-usage.sh [OPTIONS] [COMMAND]
#
# Commands:
#   statusline           Output simple one-line format for statusbars
#   "<format>"           Custom format string with placeholders
#
# Options:
#   -t, --token TOKEN    Provide OAuth access token directly
#   -s, --statusline     Same as 'statusline' command
#   -f, --format FMT     Custom format with placeholders: DD% WW% RR
#   -r, --raw            Output raw JSON response
#   -j, --json           Output as JSON (for scripting)
#   -R, --remaining      Show remaining capacity instead of usage
#   -n, --no-cache       Bypass cache and fetch fresh data
#   -h, --help           Show this help message
#

set -euo pipefail

# ============================================================================
# Configuration
# ============================================================================

ANTHROPIC_API_BASE="https://api.anthropic.com"
OAUTH_ENDPOINT="/api/oauth/usage"
OAUTH_BETA_HEADER="oauth-2025-04-20"

# Credential locations (same as Claude Code)
CREDENTIALS_FILE="$HOME/.claude/.credentials.json"
KEYCHAIN_SERVICE="Claude Code-credentials"

# Cache configuration
CACHE_DIR="$HOME/.local/share/claude-usage"
CACHE_FILE="$CACHE_DIR/cache.json"
CACHE_TTL=60  # 1 minute in seconds

RAW_OUTPUT=false
JSON_OUTPUT=false
STATUSLINE_OUTPUT=false
REMAINING_OUTPUT=false
NO_CACHE=false
ACCESS_TOKEN=""
FORMAT_STRING=""

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[0;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
NC='\033[0m'

# ============================================================================
# Helper Functions
# ============================================================================

usage() {
    cat << EOF
Usage: $(basename "$0") [OPTIONS] [COMMAND]

Fetch Claude Plan usage statistics via the Anthropic OAuth API.
Uses credentials from Claude Code (the CLI tool).

Commands:
  statusline           Output simple one-line format: "5h: X% 7d: Y%"
  "<format>"           Custom format string with placeholders (see below)

Options:
  -t, --token TOKEN    Provide OAuth access token directly
  -s, --statusline     Same as 'statusline' command
  -f, --format FMT     Custom format with placeholders (see below)
  -r, --raw            Output raw JSON response
  -j, --json           Output as JSON (for scripting)
  -R, --remaining      Show remaining capacity instead of usage
  -n, --no-cache       Bypass cache and fetch fresh data
  -h, --help           Show this help message

Format Placeholders:
  DD     5-hour (session) usage percentage (number only)
  WW     7-day (weekly) usage percentage (number only)
  RR     Reset time for 5-hour window (e.g., "3h 23m")

Prerequisites:
  1. Install Claude Code:  npm install -g @anthropic-ai/claude-code
  2. Login to Claude:      claude login
  3. Run this script:      ./$(basename "$0")

Credential Sources (in order):
  1. --token argument
  2. CLAUDE_OAUTH_TOKEN environment variable
  3. macOS Keychain (service: "Claude Code-credentials")
  4. File: ~/.claude/.credentials.json

Note: Your OAuth token must have the 'user:profile' scope.
      Tokens with only 'user:inference' cannot access usage data.

Examples:
  $(basename "$0")                        # Full usage display
  $(basename "$0") statusline             # Simple: "5h: 42% 7d: 18%"
  $(basename "$0") -s                     # Same as statusline
  $(basename "$0") -R                     # Show remaining: "5h: 58% 7d: 82%"
  $(basename "$0") -s -R                  # Statusline with remaining
  $(basename "$0") -r                     # Show raw JSON
  $(basename "$0") -j                     # Output as JSON
  $(basename "$0") -t "oauth_..."         # Use specific token
  $(basename "$0") "5d: DD% 7d: WW%"      # Custom: "5d: 65% 7d: 78%"
  $(basename "$0") "resets in RR"         # Custom: "resets in 3h 23m"
  $(basename "$0") -R "DD% left"          # Custom with remaining: "35% left"
  $(basename "$0") "DD/100"               # Custom symbol: "65/100"
EOF
    exit 0
}

error() {
    echo -e "${RED}Error:${NC} $1" >&2
    exit 1
}

info() {
    if [[ "$JSON_OUTPUT" != true && "$STATUSLINE_OUTPUT" != true && -z "$FORMAT_STRING" ]]; then
        echo -e "${BLUE}â„¹${NC} $1" >&2
    fi
}

check_dependencies() {
    if ! command -v curl &> /dev/null; then
        error "curl is required but not installed"
    fi
    if ! command -v jq &> /dev/null; then
        error "jq is required. Install with: brew install jq (macOS) or apt install jq (Linux)"
    fi
}

# ============================================================================
# Credential Retrieval
# ============================================================================

# Try to get token from macOS Keychain
get_keychain_token() {
    if [[ "$(uname)" != "Darwin" ]]; then
        return 1
    fi

    # Query the keychain for Claude Code credentials
    local keychain_data
    keychain_data=$(security find-generic-password -s "$KEYCHAIN_SERVICE" -w 2>/dev/null) || return 1

    if [[ -n "$keychain_data" ]]; then
        # The keychain stores JSON, extract the access token
        echo "$keychain_data" | jq -r '.claudeAiOauth.accessToken // .accessToken // empty' 2>/dev/null || echo ""
    fi
}

# Get token from credentials file
get_file_token() {
    if [[ ! -f "$CREDENTIALS_FILE" ]]; then
        return 1
    fi

    local token
    token=$(jq -r '.claudeAiOauth.accessToken // .accessToken // empty' "$CREDENTIALS_FILE" 2>/dev/null)

    if [[ -n "$token" && "$token" != "null" ]]; then
        echo "$token"
        return 0
    fi

    return 1
}

# Get token from any available source
get_access_token() {
    local token=""

    # 1. Environment variable
    if [[ -n "${CLAUDE_OAUTH_TOKEN:-}" ]]; then
        info "Using token from CLAUDE_OAUTH_TOKEN environment variable"
        echo "$CLAUDE_OAUTH_TOKEN"
        return 0
    fi

    # 2. macOS Keychain
    token=$(get_keychain_token 2>/dev/null) || true
    if [[ -n "$token" ]]; then
        info "Using token from macOS Keychain"
        echo "$token"
        return 0
    fi

    # 3. Credentials file
    token=$(get_file_token 2>/dev/null) || true
    if [[ -n "$token" ]]; then
        info "Using token from ~/.claude/.credentials.json"
        echo "$token"
        return 0
    fi

    return 1
}

# ============================================================================
# API Functions
# ============================================================================

fetch_usage() {
    local token="$1"

    curl -s -f \
        -H "Authorization: Bearer $token" \
        -H "Accept: application/json" \
        -H "Content-Type: application/json" \
        -H "anthropic-beta: $OAUTH_BETA_HEADER" \
        -H "User-Agent: claude-usage-script/1.0" \
        --max-time 30 \
        "${ANTHROPIC_API_BASE}${OAUTH_ENDPOINT}" 2>/dev/null
}

# ============================================================================
# Cache Functions
# ============================================================================

# Check if cache is valid (exists and not expired)
is_cache_valid() {
    if [[ ! -f "$CACHE_FILE" ]]; then
        return 1
    fi

    local cache_mtime now age
    if [[ "$(uname)" == "Darwin" ]]; then
        cache_mtime=$(stat -f %m "$CACHE_FILE" 2>/dev/null) || return 1
    else
        cache_mtime=$(stat -c %Y "$CACHE_FILE" 2>/dev/null) || return 1
    fi

    now=$(date +%s)
    age=$((now - cache_mtime))

    if [[ $age -lt $CACHE_TTL ]]; then
        return 0
    fi

    return 1
}

# Read cached data
read_cache() {
    if [[ -f "$CACHE_FILE" ]]; then
        cat "$CACHE_FILE"
    fi
}

# Write data to cache
write_cache() {
    local data="$1"

    # Ensure cache directory exists
    mkdir -p "$CACHE_DIR"

    # Write data to cache file
    echo "$data" > "$CACHE_FILE"
}

# ============================================================================
# Output Formatting
# ============================================================================

# Invert percentage if --remaining flag is set
maybe_invert() {
    local pct="$1"
    if [[ "$REMAINING_OUTPUT" == true ]]; then
        echo "$(echo "100 - $pct" | bc -l)"
    else
        echo "$pct"
    fi
}

format_percentage() {
    local pct="$1"
    local display_pct
    display_pct=$(maybe_invert "$pct")

    # Color based on original usage (not remaining)
    local color="$GREEN"
    if (( $(echo "$pct >= 90" | bc -l 2>/dev/null || echo 0) )); then
        color="$RED"
    elif (( $(echo "$pct >= 70" | bc -l 2>/dev/null || echo 0) )); then
        color="$YELLOW"
    fi

    printf "${color}%.1f%%${NC}" "$display_pct"
}

print_usage_bar() {
    local pct="$1"
    local display_pct
    display_pct=$(maybe_invert "$pct")
    local percentage="${display_pct%.*}"  # Remove decimals
    local width=30
    local filled=$((percentage * width / 100))
    local empty=$((width - filled))

    # Color based on original usage (not remaining)
    local original="${pct%.*}"
    local color="$GREEN"
    [[ $original -ge 70 ]] && color="$YELLOW"
    [[ $original -ge 90 ]] && color="$RED"

    printf "${color}"
    for ((i=0; i<filled; i++)); do printf "â–ˆ"; done
    printf "${NC}"
    for ((i=0; i<empty; i++)); do printf "â–‘"; done
}

format_reset_time() {
    local reset_time="$1"

    if [[ -z "$reset_time" || "$reset_time" == "null" ]]; then
        echo "Unknown"
        return
    fi

    # Try to parse and show human-readable time remaining
    if command -v python3 &> /dev/null; then
        python3 << PYTHON 2>/dev/null || echo "$reset_time"
from datetime import datetime
import sys

try:
    reset_str = "$reset_time"
    # Handle various ISO formats
    for fmt in ["%Y-%m-%dT%H:%M:%S.%fZ", "%Y-%m-%dT%H:%M:%SZ", "%Y-%m-%dT%H:%M:%S"]:
        try:
            reset = datetime.strptime(reset_str.replace("+00:00", "Z").split(".")[0] + "Z", "%Y-%m-%dT%H:%M:%SZ")
            break
        except:
            continue
    else:
        print(reset_str)
        sys.exit(0)

    now = datetime.utcnow()
    diff = reset - now

    if diff.total_seconds() < 0:
        print("Now")
    else:
        hours = int(diff.total_seconds() // 3600)
        minutes = int((diff.total_seconds() % 3600) // 60)
        if hours > 24:
            days = hours // 24
            hours = hours % 24
            print(f"{days}d {hours}h")
        elif hours > 0:
            print(f"{hours}h {minutes}m")
        else:
            print(f"{minutes}m")
except Exception as e:
    print("$reset_time")
PYTHON
    else
        echo "$reset_time"
    fi
}

display_usage() {
    local usage_json="$1"

    local title="Claude Plan Usage Statistics"
    [[ "$REMAINING_OUTPUT" == true ]] && title="Claude Plan Remaining Capacity"

    echo ""
    echo -e "${BOLD}${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo -e "${BOLD}${CYAN}            ${title}               ${NC}"
    echo -e "${BOLD}${CYAN}â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•${NC}"
    echo ""

    # Parse usage windows
    local five_hour_pct five_hour_reset
    local seven_day_pct seven_day_reset
    local opus_pct opus_reset
    local sonnet_pct sonnet_reset

    five_hour_pct=$(echo "$usage_json" | jq -r '.five_hour.utilization // 0')
    five_hour_reset=$(echo "$usage_json" | jq -r '.five_hour.resets_at // empty')

    seven_day_pct=$(echo "$usage_json" | jq -r '.seven_day.utilization // 0')
    seven_day_reset=$(echo "$usage_json" | jq -r '.seven_day.resets_at // empty')

    opus_pct=$(echo "$usage_json" | jq -r '.seven_day_opus.utilization // empty')
    opus_reset=$(echo "$usage_json" | jq -r '.seven_day_opus.resets_at // empty')

    sonnet_pct=$(echo "$usage_json" | jq -r '.seven_day_sonnet.utilization // empty')
    sonnet_reset=$(echo "$usage_json" | jq -r '.seven_day_sonnet.resets_at // empty')

    # Rate limit tier (plan type)
    local tier
    tier=$(echo "$usage_json" | jq -r '.rate_limit_tier // empty')
    if [[ -n "$tier" && "$tier" != "null" ]]; then
        echo -e "${BOLD}Plan:${NC} $tier"
        echo ""
    fi

    # Five-hour session window
    echo -e "${BOLD}ğŸ“Š Current Session (5-hour window)${NC}"
    printf "   "
    print_usage_bar "$five_hour_pct"
    printf " "
    format_percentage "$five_hour_pct"
    echo ""
    if [[ -n "$five_hour_reset" && "$five_hour_reset" != "null" ]]; then
        echo -e "   Resets in: ${CYAN}$(format_reset_time "$five_hour_reset")${NC}"
    fi
    echo ""

    # Seven-day window
    echo -e "${BOLD}ğŸ“… Weekly Usage (7-day window)${NC}"
    printf "   "
    print_usage_bar "$seven_day_pct"
    printf " "
    format_percentage "$seven_day_pct"
    echo ""
    if [[ -n "$seven_day_reset" && "$seven_day_reset" != "null" ]]; then
        echo -e "   Resets in: ${CYAN}$(format_reset_time "$seven_day_reset")${NC}"
    fi
    echo ""

    # Model-specific usage (Opus)
    if [[ -n "$opus_pct" && "$opus_pct" != "null" && "$opus_pct" != "0" ]]; then
        echo -e "${BOLD}ğŸ­ Opus Weekly Usage${NC}"
        printf "   "
        print_usage_bar "$opus_pct"
        printf " "
        format_percentage "$opus_pct"
        echo ""
        if [[ -n "$opus_reset" && "$opus_reset" != "null" ]]; then
            echo -e "   Resets in: ${CYAN}$(format_reset_time "$opus_reset")${NC}"
        fi
        echo ""
    fi

    # Model-specific usage (Sonnet)
    if [[ -n "$sonnet_pct" && "$sonnet_pct" != "null" && "$sonnet_pct" != "0" ]]; then
        echo -e "${BOLD}âœ¨ Sonnet Weekly Usage${NC}"
        printf "   "
        print_usage_bar "$sonnet_pct"
        printf " "
        format_percentage "$sonnet_pct"
        echo ""
        if [[ -n "$sonnet_reset" && "$sonnet_reset" != "null" ]]; then
            echo -e "   Resets in: ${CYAN}$(format_reset_time "$sonnet_reset")${NC}"
        fi
        echo ""
    fi

    # Extra usage (Claude Extra / Premium)
    local extra_enabled extra_used extra_limit extra_pct extra_currency
    extra_enabled=$(echo "$usage_json" | jq -r '.extra_usage.is_enabled // false')

    if [[ "$extra_enabled" == "true" ]]; then
        extra_used=$(echo "$usage_json" | jq -r '.extra_usage.used_credits // 0')
        extra_limit=$(echo "$usage_json" | jq -r '.extra_usage.monthly_limit // 0')
        extra_pct=$(echo "$usage_json" | jq -r '.extra_usage.utilization // 0')
        extra_currency=$(echo "$usage_json" | jq -r '.extra_usage.currency // "USD"')

        local extra_label="Claude Extra Usage"
        local credits_label="Used"
        local credits_value="$extra_used"
        if [[ "$REMAINING_OUTPUT" == true ]]; then
            extra_label="Claude Extra Remaining"
            credits_label="Remaining"
            credits_value=$(echo "$extra_limit - $extra_used" | bc -l)
        fi

        echo -e "${BOLD}  ${extra_label}${NC}"
        printf "   "
        print_usage_bar "$extra_pct"
        printf " "
        format_percentage "$extra_pct"
        echo ""
        echo -e "   ${credits_label}: ${GREEN}\$${credits_value}${NC} / \$${extra_limit} ${extra_currency}"
        echo ""
    fi

    echo -e "${CYAN}â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€${NC}"
    echo -e "Fetched: $(date '+%Y-%m-%d %H:%M:%S %Z')"
    echo ""
}

output_json() {
    local usage_json="$1"

    if [[ "$REMAINING_OUTPUT" == true ]]; then
        # Invert utilization values to show remaining capacity
        echo "$usage_json" | jq '{
            five_hour: {
                remaining: (100 - (.five_hour.utilization // 0)),
                resets_at: .five_hour.resets_at
            },
            seven_day: {
                remaining: (100 - (.seven_day.utilization // 0)),
                resets_at: .seven_day.resets_at
            },
            seven_day_opus: (if .seven_day_opus then {remaining: (100 - (.seven_day_opus.utilization // 0)), resets_at: .seven_day_opus.resets_at} else null end),
            seven_day_sonnet: (if .seven_day_sonnet then {remaining: (100 - (.seven_day_sonnet.utilization // 0)), resets_at: .seven_day_sonnet.resets_at} else null end),
            extra_usage: (if .extra_usage.is_enabled then {is_enabled: true, remaining: (100 - (.extra_usage.utilization // 0)), remaining_credits: ((.extra_usage.monthly_limit // 0) - (.extra_usage.used_credits // 0)), currency: .extra_usage.currency} else .extra_usage end),
            rate_limit_tier: .rate_limit_tier
        }'
    else
        # Create a simplified JSON output
        echo "$usage_json" | jq '{
            five_hour: {
                utilization: .five_hour.utilization,
                resets_at: .five_hour.resets_at
            },
            seven_day: {
                utilization: .seven_day.utilization,
                resets_at: .seven_day.resets_at
            },
            seven_day_opus: .seven_day_opus,
            seven_day_sonnet: .seven_day_sonnet,
            extra_usage: .extra_usage,
            rate_limit_tier: .rate_limit_tier
        }'
    fi
}

display_statusline() {
    local usage_json="$1"

    local five_hour_pct seven_day_pct
    five_hour_pct=$(echo "$usage_json" | jq -r '.five_hour.utilization // 0')
    seven_day_pct=$(echo "$usage_json" | jq -r '.seven_day.utilization // 0')

    # Invert if showing remaining
    five_hour_pct=$(maybe_invert "$five_hour_pct")
    seven_day_pct=$(maybe_invert "$seven_day_pct")

    # Round to integers for cleaner statusline
    local five_int seven_int
    five_int=$(printf "%.0f" "$five_hour_pct")
    seven_int=$(printf "%.0f" "$seven_day_pct")

    echo "5h: ${five_int}% 7d: ${seven_int}%"
}

display_format() {
    local usage_json="$1"
    local format="$2"

    local five_hour_pct seven_day_pct five_hour_reset
    five_hour_pct=$(echo "$usage_json" | jq -r '.five_hour.utilization // 0')
    seven_day_pct=$(echo "$usage_json" | jq -r '.seven_day.utilization // 0')
    five_hour_reset=$(echo "$usage_json" | jq -r '.five_hour.resets_at // empty')

    # Invert if showing remaining
    five_hour_pct=$(maybe_invert "$five_hour_pct")
    seven_day_pct=$(maybe_invert "$seven_day_pct")

    # Round to integers
    local five_int seven_int
    five_int=$(printf "%.0f" "$five_hour_pct")
    seven_int=$(printf "%.0f" "$seven_day_pct")

    # Get formatted reset time
    local reset_formatted
    reset_formatted=$(format_reset_time "$five_hour_reset")

    # Replace placeholders (just numbers, users add their own symbols)
    local output="$format"
    output="${output//DD/${five_int}}"
    output="${output//WW/${seven_int}}"
    output="${output//RR/${reset_formatted}}"

    echo "$output"
}

# ============================================================================
# Main
# ============================================================================

main() {
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case "$1" in
            statusline)
                STATUSLINE_OUTPUT=true
                shift
                ;;
            -s|--statusline)
                STATUSLINE_OUTPUT=true
                shift
                ;;
            -t|--token)
                ACCESS_TOKEN="$2"
                shift 2
                ;;
            -f|--format)
                FORMAT_STRING="$2"
                shift 2
                ;;
            -r|--raw)
                RAW_OUTPUT=true
                shift
                ;;
            -j|--json)
                JSON_OUTPUT=true
                shift
                ;;
            -R|--remaining)
                REMAINING_OUTPUT=true
                shift
                ;;
            -n|--no-cache)
                NO_CACHE=true
                shift
                ;;
            -h|--help)
                usage
                ;;
            *)
                # Check if argument is a format string (contains DD, WW, or RR)
                if [[ "$1" =~ DD|WW|RR ]]; then
                    FORMAT_STRING="$1"
                    shift
                else
                    error "Unknown option: $1\nRun '$(basename "$0") --help' for usage"
                fi
                ;;
        esac
    done

    check_dependencies

    # Get access token
    if [[ -z "$ACCESS_TOKEN" ]]; then
        ACCESS_TOKEN=$(get_access_token) || {
            error "No OAuth credentials found.\n\nTo set up credentials:\n  1. Install Claude Code: npm install -g @anthropic-ai/claude-code\n  2. Login: claude login\n  3. Run this script again\n\nOr provide a token directly: $(basename "$0") --token <your-token>"
        }
    fi

    if [[ -z "$ACCESS_TOKEN" ]]; then
        error "Failed to obtain access token"
    fi

    # Fetch usage (with caching)
    local usage_json

    if [[ "$NO_CACHE" != true ]] && is_cache_valid; then
        info "Using cached data (less than 1 minute old)"
        usage_json=$(read_cache)
    else
        info "Fetching usage from Anthropic API..."
        usage_json=$(fetch_usage "$ACCESS_TOKEN") || {
            error "Failed to fetch usage data.\n\nThis could mean:\n  - Your token has expired (run 'claude login' again)\n  - Your token lacks 'user:profile' scope\n  - Network connectivity issues"
        }

        if [[ -z "$usage_json" ]]; then
            error "Empty response from API"
        fi

        # Save to cache
        write_cache "$usage_json"
    fi

    # Output based on format
    if [[ "$RAW_OUTPUT" == true ]]; then
        echo "$usage_json" | jq .
    elif [[ "$JSON_OUTPUT" == true ]]; then
        output_json "$usage_json"
    elif [[ -n "$FORMAT_STRING" ]]; then
        display_format "$usage_json" "$FORMAT_STRING"
    elif [[ "$STATUSLINE_OUTPUT" == true ]]; then
        display_statusline "$usage_json"
    else
        display_usage "$usage_json"
    fi
}

main "$@"
